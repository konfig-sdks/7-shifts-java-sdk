/*
 * 7shifts API
 * 7shifts is a team management software designed for restaurants. We help managers and operators spend less time and effort scheduling their staff, reduce their monthly labor costs and improve team communication. The result is simplified team management, one shift at a time.  7shifts also offers free mobile apps (iOS and Android) allowing managers and employees to have everything at their fingertips.  Start your free trial or request a demo at www.7shifts.com.
 *
 * The version of the OpenAPI document: 2023-05-01
 * Contact: api-support@7shifts.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.time.OffsetDateTime;
import com.konfigthis.client.model.TimePunchesCreateRequest;
import com.konfigthis.client.model.TimePunchesCreateRequestBreaksInner;
import com.konfigthis.client.model.TimePunchesCreateResponse;
import com.konfigthis.client.model.TimePunchesGetTimePunchResponse;
import com.konfigthis.client.model.TimePunchesListResponse;
import com.konfigthis.client.model.TimePunchesUpdateByIdRequest;
import com.konfigthis.client.model.TimePunchesUpdateByIdRequestBreaksInner;
import com.konfigthis.client.model.TimePunchesUpdateByIdResponse;
import java.util.UUID;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class TimePunchesApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public TimePunchesApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public TimePunchesApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call createCall(Long companyId, TimePunchesCreateRequest timePunchesCreateRequest, String xApiVersion, UUID xCompanyGuid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = timePunchesCreateRequest;

        // create path and map variables
        String localVarPath = "/v2/company/{company_id}/time_punches"
            .replace("{" + "company_id" + "}", localVarApiClient.escapeString(companyId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xApiVersion != null) {
            localVarHeaderParams.put("x-api-version", localVarApiClient.parameterToString(xApiVersion));
        }

        if (xCompanyGuid != null) {
            localVarHeaderParams.put("x-company-guid", localVarApiClient.parameterToString(xCompanyGuid));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/problem+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "OAuth2", "OAuth2", "cookieAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createValidateBeforeCall(Long companyId, TimePunchesCreateRequest timePunchesCreateRequest, String xApiVersion, UUID xCompanyGuid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'companyId' is set
        if (companyId == null) {
            throw new ApiException("Missing the required parameter 'companyId' when calling create(Async)");
        }

        // verify the required parameter 'timePunchesCreateRequest' is set
        if (timePunchesCreateRequest == null) {
            throw new ApiException("Missing the required parameter 'timePunchesCreateRequest' when calling create(Async)");
        }

        return createCall(companyId, timePunchesCreateRequest, xApiVersion, xCompanyGuid, _callback);

    }


    private ApiResponse<TimePunchesCreateResponse> createWithHttpInfo(Long companyId, TimePunchesCreateRequest timePunchesCreateRequest, String xApiVersion, UUID xCompanyGuid) throws ApiException {
        okhttp3.Call localVarCall = createValidateBeforeCall(companyId, timePunchesCreateRequest, xApiVersion, xCompanyGuid, null);
        Type localVarReturnType = new TypeToken<TimePunchesCreateResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createAsync(Long companyId, TimePunchesCreateRequest timePunchesCreateRequest, String xApiVersion, UUID xCompanyGuid, final ApiCallback<TimePunchesCreateResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createValidateBeforeCall(companyId, timePunchesCreateRequest, xApiVersion, xCompanyGuid, _callback);
        Type localVarReturnType = new TypeToken<TimePunchesCreateResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateRequestBuilder {
        private final Integer locationId;
        private final Integer userId;
        private final OffsetDateTime clockedIn;
        private final Long companyId;
        private Integer departmentId;
        private Integer roleId;
        private OffsetDateTime clockedOut;
        private String notes;
        private Integer tips;
        private List<TimePunchesCreateRequestBreaksInner> breaks;
        private String xApiVersion;
        private UUID xCompanyGuid;

        private CreateRequestBuilder(Integer locationId, Integer userId, OffsetDateTime clockedIn, Long companyId) {
            this.locationId = locationId;
            this.userId = userId;
            this.clockedIn = clockedIn;
            this.companyId = companyId;
        }

        /**
         * Set departmentId
         * @param departmentId Department ID. Defaults to 0 if not defined. (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder departmentId(Integer departmentId) {
            this.departmentId = departmentId;
            return this;
        }
        
        /**
         * Set roleId
         * @param roleId The ID of the role that the user is clocking in to work for. Defaults to 0 if not defined. (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder roleId(Integer roleId) {
            this.roleId = roleId;
            return this;
        }
        
        /**
         * Set clockedOut
         * @param clockedOut The start date and time when the user clocked out. Formatted as ISO8601 datetime in UTC timezone. (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder clockedOut(OffsetDateTime clockedOut) {
            this.clockedOut = clockedOut;
            return this;
        }
        
        /**
         * Set notes
         * @param notes Additional notes for a shift. (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder notes(String notes) {
            this.notes = notes;
            return this;
        }
        
        /**
         * Set tips
         * @param tips Tips declared for the shift in cents (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder tips(Integer tips) {
            this.tips = tips;
            return this;
        }
        
        /**
         * Set breaks
         * @param breaks  (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder breaks(List<TimePunchesCreateRequestBreaksInner> breaks) {
            this.breaks = breaks;
            return this;
        }
        
        /**
         * Set xApiVersion
         * @param xApiVersion 7shifts API version (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder xApiVersion(String xApiVersion) {
            this.xApiVersion = xApiVersion;
            return this;
        }
        
        /**
         * Set xCompanyGuid
         * @param xCompanyGuid Company GUID (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder xCompanyGuid(UUID xCompanyGuid) {
            this.xCompanyGuid = xCompanyGuid;
            return this;
        }
        
        /**
         * Build call for create
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            TimePunchesCreateRequest timePunchesCreateRequest = buildBodyParams();
            return createCall(companyId, timePunchesCreateRequest, xApiVersion, xCompanyGuid, _callback);
        }

        private TimePunchesCreateRequest buildBodyParams() {
            TimePunchesCreateRequest timePunchesCreateRequest = new TimePunchesCreateRequest();
            timePunchesCreateRequest.locationId(this.locationId);
            timePunchesCreateRequest.departmentId(this.departmentId);
            timePunchesCreateRequest.userId(this.userId);
            timePunchesCreateRequest.roleId(this.roleId);
            timePunchesCreateRequest.clockedIn(this.clockedIn);
            timePunchesCreateRequest.clockedOut(this.clockedOut);
            timePunchesCreateRequest.notes(this.notes);
            timePunchesCreateRequest.tips(this.tips);
            timePunchesCreateRequest.breaks(this.breaks);
            return timePunchesCreateRequest;
        }

        /**
         * Execute create request
         * @return TimePunchesCreateResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
         </table>
         */
        public TimePunchesCreateResponse execute() throws ApiException {
            TimePunchesCreateRequest timePunchesCreateRequest = buildBodyParams();
            ApiResponse<TimePunchesCreateResponse> localVarResp = createWithHttpInfo(companyId, timePunchesCreateRequest, xApiVersion, xCompanyGuid);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute create request with HTTP info returned
         * @return ApiResponse&lt;TimePunchesCreateResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TimePunchesCreateResponse> executeWithHttpInfo() throws ApiException {
            TimePunchesCreateRequest timePunchesCreateRequest = buildBodyParams();
            return createWithHttpInfo(companyId, timePunchesCreateRequest, xApiVersion, xCompanyGuid);
        }

        /**
         * Execute create request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TimePunchesCreateResponse> _callback) throws ApiException {
            TimePunchesCreateRequest timePunchesCreateRequest = buildBodyParams();
            return createAsync(companyId, timePunchesCreateRequest, xApiVersion, xCompanyGuid, _callback);
        }
    }

    /**
     * Create Time Punch
     * 
     * @param companyId The company id (required)
     * @param timePunchesCreateRequest  (required)
     * @return CreateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public CreateRequestBuilder create(Integer locationId, Integer userId, OffsetDateTime clockedIn, Long companyId) throws IllegalArgumentException {
        if (locationId == null) throw new IllegalArgumentException("\"locationId\" is required but got null");
        if (userId == null) throw new IllegalArgumentException("\"userId\" is required but got null");
        if (clockedIn == null) throw new IllegalArgumentException("\"clockedIn\" is required but got null");
        if (companyId == null) throw new IllegalArgumentException("\"companyId\" is required but got null");
        return new CreateRequestBuilder(locationId, userId, clockedIn, companyId);
    }
    private okhttp3.Call deleteByIdCall(Long companyId, Long timePunchId, String xApiVersion, UUID xCompanyGuid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/company/{company_id}/time_punches/{time_punch_id}"
            .replace("{" + "company_id" + "}", localVarApiClient.escapeString(companyId.toString()))
            .replace("{" + "time_punch_id" + "}", localVarApiClient.escapeString(timePunchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xApiVersion != null) {
            localVarHeaderParams.put("x-api-version", localVarApiClient.parameterToString(xApiVersion));
        }

        if (xCompanyGuid != null) {
            localVarHeaderParams.put("x-company-guid", localVarApiClient.parameterToString(xCompanyGuid));
        }

        final String[] localVarAccepts = {
            "application/problem+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "OAuth2", "OAuth2", "cookieAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteByIdValidateBeforeCall(Long companyId, Long timePunchId, String xApiVersion, UUID xCompanyGuid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'companyId' is set
        if (companyId == null) {
            throw new ApiException("Missing the required parameter 'companyId' when calling deleteById(Async)");
        }

        // verify the required parameter 'timePunchId' is set
        if (timePunchId == null) {
            throw new ApiException("Missing the required parameter 'timePunchId' when calling deleteById(Async)");
        }

        return deleteByIdCall(companyId, timePunchId, xApiVersion, xCompanyGuid, _callback);

    }


    private ApiResponse<Void> deleteByIdWithHttpInfo(Long companyId, Long timePunchId, String xApiVersion, UUID xCompanyGuid) throws ApiException {
        okhttp3.Call localVarCall = deleteByIdValidateBeforeCall(companyId, timePunchId, xApiVersion, xCompanyGuid, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteByIdAsync(Long companyId, Long timePunchId, String xApiVersion, UUID xCompanyGuid, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteByIdValidateBeforeCall(companyId, timePunchId, xApiVersion, xCompanyGuid, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteByIdRequestBuilder {
        private final Long companyId;
        private final Long timePunchId;
        private String xApiVersion;
        private UUID xCompanyGuid;

        private DeleteByIdRequestBuilder(Long companyId, Long timePunchId) {
            this.companyId = companyId;
            this.timePunchId = timePunchId;
        }

        /**
         * Set xApiVersion
         * @param xApiVersion 7shifts API version (optional)
         * @return DeleteByIdRequestBuilder
         */
        public DeleteByIdRequestBuilder xApiVersion(String xApiVersion) {
            this.xApiVersion = xApiVersion;
            return this;
        }
        
        /**
         * Set xCompanyGuid
         * @param xCompanyGuid Company GUID (optional)
         * @return DeleteByIdRequestBuilder
         */
        public DeleteByIdRequestBuilder xCompanyGuid(UUID xCompanyGuid) {
            this.xCompanyGuid = xCompanyGuid;
            return this;
        }
        
        /**
         * Build call for deleteById
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteByIdCall(companyId, timePunchId, xApiVersion, xCompanyGuid, _callback);
        }


        /**
         * Execute deleteById request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteByIdWithHttpInfo(companyId, timePunchId, xApiVersion, xCompanyGuid);
        }

        /**
         * Execute deleteById request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteByIdWithHttpInfo(companyId, timePunchId, xApiVersion, xCompanyGuid);
        }

        /**
         * Execute deleteById request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteByIdAsync(companyId, timePunchId, xApiVersion, xCompanyGuid, _callback);
        }
    }

    /**
     * Delete Time Punch
     * 
     * @param companyId Company ID (required)
     * @param timePunchId Time punch ID (required)
     * @return DeleteByIdRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public DeleteByIdRequestBuilder deleteById(Long companyId, Long timePunchId) throws IllegalArgumentException {
        if (companyId == null) throw new IllegalArgumentException("\"companyId\" is required but got null");
        if (timePunchId == null) throw new IllegalArgumentException("\"timePunchId\" is required but got null");
        return new DeleteByIdRequestBuilder(companyId, timePunchId);
    }
    private okhttp3.Call getTimePunchCall(Long companyId, Long timePunchId, String xApiVersion, UUID xCompanyGuid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/company/{company_id}/time_punches/{time_punch_id}"
            .replace("{" + "company_id" + "}", localVarApiClient.escapeString(companyId.toString()))
            .replace("{" + "time_punch_id" + "}", localVarApiClient.escapeString(timePunchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xApiVersion != null) {
            localVarHeaderParams.put("x-api-version", localVarApiClient.parameterToString(xApiVersion));
        }

        if (xCompanyGuid != null) {
            localVarHeaderParams.put("x-company-guid", localVarApiClient.parameterToString(xCompanyGuid));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/problem+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "OAuth2", "OAuth2", "cookieAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTimePunchValidateBeforeCall(Long companyId, Long timePunchId, String xApiVersion, UUID xCompanyGuid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'companyId' is set
        if (companyId == null) {
            throw new ApiException("Missing the required parameter 'companyId' when calling getTimePunch(Async)");
        }

        // verify the required parameter 'timePunchId' is set
        if (timePunchId == null) {
            throw new ApiException("Missing the required parameter 'timePunchId' when calling getTimePunch(Async)");
        }

        return getTimePunchCall(companyId, timePunchId, xApiVersion, xCompanyGuid, _callback);

    }


    private ApiResponse<TimePunchesGetTimePunchResponse> getTimePunchWithHttpInfo(Long companyId, Long timePunchId, String xApiVersion, UUID xCompanyGuid) throws ApiException {
        okhttp3.Call localVarCall = getTimePunchValidateBeforeCall(companyId, timePunchId, xApiVersion, xCompanyGuid, null);
        Type localVarReturnType = new TypeToken<TimePunchesGetTimePunchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getTimePunchAsync(Long companyId, Long timePunchId, String xApiVersion, UUID xCompanyGuid, final ApiCallback<TimePunchesGetTimePunchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTimePunchValidateBeforeCall(companyId, timePunchId, xApiVersion, xCompanyGuid, _callback);
        Type localVarReturnType = new TypeToken<TimePunchesGetTimePunchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetTimePunchRequestBuilder {
        private final Long companyId;
        private final Long timePunchId;
        private String xApiVersion;
        private UUID xCompanyGuid;

        private GetTimePunchRequestBuilder(Long companyId, Long timePunchId) {
            this.companyId = companyId;
            this.timePunchId = timePunchId;
        }

        /**
         * Set xApiVersion
         * @param xApiVersion 7shifts API version (optional)
         * @return GetTimePunchRequestBuilder
         */
        public GetTimePunchRequestBuilder xApiVersion(String xApiVersion) {
            this.xApiVersion = xApiVersion;
            return this;
        }
        
        /**
         * Set xCompanyGuid
         * @param xCompanyGuid Company GUID (optional)
         * @return GetTimePunchRequestBuilder
         */
        public GetTimePunchRequestBuilder xCompanyGuid(UUID xCompanyGuid) {
            this.xCompanyGuid = xCompanyGuid;
            return this;
        }
        
        /**
         * Build call for getTimePunch
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getTimePunchCall(companyId, timePunchId, xApiVersion, xCompanyGuid, _callback);
        }


        /**
         * Execute getTimePunch request
         * @return TimePunchesGetTimePunchResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public TimePunchesGetTimePunchResponse execute() throws ApiException {
            ApiResponse<TimePunchesGetTimePunchResponse> localVarResp = getTimePunchWithHttpInfo(companyId, timePunchId, xApiVersion, xCompanyGuid);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getTimePunch request with HTTP info returned
         * @return ApiResponse&lt;TimePunchesGetTimePunchResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TimePunchesGetTimePunchResponse> executeWithHttpInfo() throws ApiException {
            return getTimePunchWithHttpInfo(companyId, timePunchId, xApiVersion, xCompanyGuid);
        }

        /**
         * Execute getTimePunch request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TimePunchesGetTimePunchResponse> _callback) throws ApiException {
            return getTimePunchAsync(companyId, timePunchId, xApiVersion, xCompanyGuid, _callback);
        }
    }

    /**
     * Retrieve Time Punch
     * 
     * @param companyId Company ID (required)
     * @param timePunchId Time punch ID (required)
     * @return GetTimePunchRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetTimePunchRequestBuilder getTimePunch(Long companyId, Long timePunchId) throws IllegalArgumentException {
        if (companyId == null) throw new IllegalArgumentException("\"companyId\" is required but got null");
        if (timePunchId == null) throw new IllegalArgumentException("\"timePunchId\" is required but got null");
        return new GetTimePunchRequestBuilder(companyId, timePunchId);
    }
    private okhttp3.Call listCall(Long companyId, String xApiVersion, UUID xCompanyGuid, Integer locationId, Integer departmentId, Integer roleId, Integer userId, Boolean approved, Integer limit, OffsetDateTime modifiedSince, OffsetDateTime clockedInLte, OffsetDateTime clockedInGte, OffsetDateTime clockedOutLte, OffsetDateTime clockedOutGte, Boolean includeDeleted, Boolean deleted, Boolean localizeSearchTime, String cursor, String sortBy, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/company/{company_id}/time_punches"
            .replace("{" + "company_id" + "}", localVarApiClient.escapeString(companyId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (locationId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("location_id", locationId));
        }

        if (departmentId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("department_id", departmentId));
        }

        if (roleId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("role_id", roleId));
        }

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("user_id", userId));
        }

        if (approved != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("approved", approved));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (modifiedSince != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("modified_since", modifiedSince));
        }

        if (clockedInLte != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("clocked_in[lte]", clockedInLte));
        }

        if (clockedInGte != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("clocked_in[gte]", clockedInGte));
        }

        if (clockedOutLte != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("clocked_out[lte]", clockedOutLte));
        }

        if (clockedOutGte != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("clocked_out[gte]", clockedOutGte));
        }

        if (includeDeleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_deleted", includeDeleted));
        }

        if (deleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deleted", deleted));
        }

        if (localizeSearchTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("localize_search_time", localizeSearchTime));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort_by", sortBy));
        }

        if (xApiVersion != null) {
            localVarHeaderParams.put("x-api-version", localVarApiClient.parameterToString(xApiVersion));
        }

        if (xCompanyGuid != null) {
            localVarHeaderParams.put("x-company-guid", localVarApiClient.parameterToString(xCompanyGuid));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/problem+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "OAuth2", "OAuth2", "cookieAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listValidateBeforeCall(Long companyId, String xApiVersion, UUID xCompanyGuid, Integer locationId, Integer departmentId, Integer roleId, Integer userId, Boolean approved, Integer limit, OffsetDateTime modifiedSince, OffsetDateTime clockedInLte, OffsetDateTime clockedInGte, OffsetDateTime clockedOutLte, OffsetDateTime clockedOutGte, Boolean includeDeleted, Boolean deleted, Boolean localizeSearchTime, String cursor, String sortBy, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'companyId' is set
        if (companyId == null) {
            throw new ApiException("Missing the required parameter 'companyId' when calling list(Async)");
        }

        return listCall(companyId, xApiVersion, xCompanyGuid, locationId, departmentId, roleId, userId, approved, limit, modifiedSince, clockedInLte, clockedInGte, clockedOutLte, clockedOutGte, includeDeleted, deleted, localizeSearchTime, cursor, sortBy, _callback);

    }


    private ApiResponse<TimePunchesListResponse> listWithHttpInfo(Long companyId, String xApiVersion, UUID xCompanyGuid, Integer locationId, Integer departmentId, Integer roleId, Integer userId, Boolean approved, Integer limit, OffsetDateTime modifiedSince, OffsetDateTime clockedInLte, OffsetDateTime clockedInGte, OffsetDateTime clockedOutLte, OffsetDateTime clockedOutGte, Boolean includeDeleted, Boolean deleted, Boolean localizeSearchTime, String cursor, String sortBy) throws ApiException {
        okhttp3.Call localVarCall = listValidateBeforeCall(companyId, xApiVersion, xCompanyGuid, locationId, departmentId, roleId, userId, approved, limit, modifiedSince, clockedInLte, clockedInGte, clockedOutLte, clockedOutGte, includeDeleted, deleted, localizeSearchTime, cursor, sortBy, null);
        Type localVarReturnType = new TypeToken<TimePunchesListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listAsync(Long companyId, String xApiVersion, UUID xCompanyGuid, Integer locationId, Integer departmentId, Integer roleId, Integer userId, Boolean approved, Integer limit, OffsetDateTime modifiedSince, OffsetDateTime clockedInLte, OffsetDateTime clockedInGte, OffsetDateTime clockedOutLte, OffsetDateTime clockedOutGte, Boolean includeDeleted, Boolean deleted, Boolean localizeSearchTime, String cursor, String sortBy, final ApiCallback<TimePunchesListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listValidateBeforeCall(companyId, xApiVersion, xCompanyGuid, locationId, departmentId, roleId, userId, approved, limit, modifiedSince, clockedInLte, clockedInGte, clockedOutLte, clockedOutGte, includeDeleted, deleted, localizeSearchTime, cursor, sortBy, _callback);
        Type localVarReturnType = new TypeToken<TimePunchesListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListRequestBuilder {
        private final Long companyId;
        private String xApiVersion;
        private UUID xCompanyGuid;
        private Integer locationId;
        private Integer departmentId;
        private Integer roleId;
        private Integer userId;
        private Boolean approved;
        private Integer limit;
        private OffsetDateTime modifiedSince;
        private OffsetDateTime clockedInLte;
        private OffsetDateTime clockedInGte;
        private OffsetDateTime clockedOutLte;
        private OffsetDateTime clockedOutGte;
        private Boolean includeDeleted;
        private Boolean deleted;
        private Boolean localizeSearchTime;
        private String cursor;
        private String sortBy;

        private ListRequestBuilder(Long companyId) {
            this.companyId = companyId;
        }

        /**
         * Set xApiVersion
         * @param xApiVersion 7shifts API version (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder xApiVersion(String xApiVersion) {
            this.xApiVersion = xApiVersion;
            return this;
        }
        
        /**
         * Set xCompanyGuid
         * @param xCompanyGuid Company GUID (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder xCompanyGuid(UUID xCompanyGuid) {
            this.xCompanyGuid = xCompanyGuid;
            return this;
        }
        
        /**
         * Set locationId
         * @param locationId Location ID (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder locationId(Integer locationId) {
            this.locationId = locationId;
            return this;
        }
        
        /**
         * Set departmentId
         * @param departmentId Department ID (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder departmentId(Integer departmentId) {
            this.departmentId = departmentId;
            return this;
        }
        
        /**
         * Set roleId
         * @param roleId Role ID (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder roleId(Integer roleId) {
            this.roleId = roleId;
            return this;
        }
        
        /**
         * Set userId
         * @param userId User ID (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder userId(Integer userId) {
            this.userId = userId;
            return this;
        }
        
        /**
         * Set approved
         * @param approved Returns time punches that have been approved. Default null, returns both approved and unapproved punches. If true returns only approved punches. If false returns only unapproved punches. (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder approved(Boolean approved) {
            this.approved = approved;
            return this;
        }
        
        /**
         * Set limit
         * @param limit The limit of results that will be returned. (optional, default to 20)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set modifiedSince
         * @param modifiedSince Return time punches that have been modified after the specified date time. UTC in ISO8601 Format (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder modifiedSince(OffsetDateTime modifiedSince) {
            this.modifiedSince = modifiedSince;
            return this;
        }
        
        /**
         * Set clockedInLte
         * @param clockedInLte Return time punches with clocked in before or on the specified date.  UTC in ISO8601 format (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder clockedInLte(OffsetDateTime clockedInLte) {
            this.clockedInLte = clockedInLte;
            return this;
        }
        
        /**
         * Set clockedInGte
         * @param clockedInGte Return time punches with clocked in after or on the specified date.  UTC in ISO8601 format (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder clockedInGte(OffsetDateTime clockedInGte) {
            this.clockedInGte = clockedInGte;
            return this;
        }
        
        /**
         * Set clockedOutLte
         * @param clockedOutLte Return time punches with clocked out before or on the specified date.  UTC in ISO8601 format (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder clockedOutLte(OffsetDateTime clockedOutLte) {
            this.clockedOutLte = clockedOutLte;
            return this;
        }
        
        /**
         * Set clockedOutGte
         * @param clockedOutGte Return time punches with clocked out after or on the specified date.  UTC in ISO8601 format (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder clockedOutGte(OffsetDateTime clockedOutGte) {
            this.clockedOutGte = clockedOutGte;
            return this;
        }
        
        /**
         * Set includeDeleted
         * @param includeDeleted Deprecated, see &#39;deleted&#39; (optional, default to false)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder includeDeleted(Boolean includeDeleted) {
            this.includeDeleted = includeDeleted;
            return this;
        }
        
        /**
         * Set deleted
         * @param deleted Returns punches filtered by deleted status.  Default false, returns undeleted punches. If true returns only deleted punches. if value is null then returns both deleted and undeleted punches. (optional, default to false)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder deleted(Boolean deleted) {
            this.deleted = deleted;
            return this;
        }
        
        /**
         * Set localizeSearchTime
         * @param localizeSearchTime If true, convert any date ranges to consider the local timezone of the punches.  If false, date ranges will be in UTC (optional, default to false)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder localizeSearchTime(Boolean localizeSearchTime) {
            this.localizeSearchTime = localizeSearchTime;
            return this;
        }
        
        /**
         * Set cursor
         * @param cursor Cursor for the next or previous page of results. (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder cursor(String cursor) {
            this.cursor = cursor;
            return this;
        }
        
        /**
         * Set sortBy
         * @param sortBy The name of the field and direction you want the results ordered by. (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder sortBy(String sortBy) {
            this.sortBy = sortBy;
            return this;
        }
        
        /**
         * Build call for list
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listCall(companyId, xApiVersion, xCompanyGuid, locationId, departmentId, roleId, userId, approved, limit, modifiedSince, clockedInLte, clockedInGte, clockedOutLte, clockedOutGte, includeDeleted, deleted, localizeSearchTime, cursor, sortBy, _callback);
        }


        /**
         * Execute list request
         * @return TimePunchesListResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public TimePunchesListResponse execute() throws ApiException {
            ApiResponse<TimePunchesListResponse> localVarResp = listWithHttpInfo(companyId, xApiVersion, xCompanyGuid, locationId, departmentId, roleId, userId, approved, limit, modifiedSince, clockedInLte, clockedInGte, clockedOutLte, clockedOutGte, includeDeleted, deleted, localizeSearchTime, cursor, sortBy);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute list request with HTTP info returned
         * @return ApiResponse&lt;TimePunchesListResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TimePunchesListResponse> executeWithHttpInfo() throws ApiException {
            return listWithHttpInfo(companyId, xApiVersion, xCompanyGuid, locationId, departmentId, roleId, userId, approved, limit, modifiedSince, clockedInLte, clockedInGte, clockedOutLte, clockedOutGte, includeDeleted, deleted, localizeSearchTime, cursor, sortBy);
        }

        /**
         * Execute list request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TimePunchesListResponse> _callback) throws ApiException {
            return listAsync(companyId, xApiVersion, xCompanyGuid, locationId, departmentId, roleId, userId, approved, limit, modifiedSince, clockedInLte, clockedInGte, clockedOutLte, clockedOutGte, includeDeleted, deleted, localizeSearchTime, cursor, sortBy, _callback);
        }
    }

    /**
     * List Time Punches
     * 
     * @param companyId Company ID (required)
     * @return ListRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ListRequestBuilder list(Long companyId) throws IllegalArgumentException {
        if (companyId == null) throw new IllegalArgumentException("\"companyId\" is required but got null");
        return new ListRequestBuilder(companyId);
    }
    private okhttp3.Call updateByIdCall(Long companyId, Long timePunchId, TimePunchesUpdateByIdRequest timePunchesUpdateByIdRequest, String xApiVersion, UUID xCompanyGuid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = timePunchesUpdateByIdRequest;

        // create path and map variables
        String localVarPath = "/v2/company/{company_id}/time_punches/{time_punch_id}"
            .replace("{" + "company_id" + "}", localVarApiClient.escapeString(companyId.toString()))
            .replace("{" + "time_punch_id" + "}", localVarApiClient.escapeString(timePunchId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xApiVersion != null) {
            localVarHeaderParams.put("x-api-version", localVarApiClient.parameterToString(xApiVersion));
        }

        if (xCompanyGuid != null) {
            localVarHeaderParams.put("x-company-guid", localVarApiClient.parameterToString(xCompanyGuid));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/problem+json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "OAuth2", "OAuth2", "cookieAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateByIdValidateBeforeCall(Long companyId, Long timePunchId, TimePunchesUpdateByIdRequest timePunchesUpdateByIdRequest, String xApiVersion, UUID xCompanyGuid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'companyId' is set
        if (companyId == null) {
            throw new ApiException("Missing the required parameter 'companyId' when calling updateById(Async)");
        }

        // verify the required parameter 'timePunchId' is set
        if (timePunchId == null) {
            throw new ApiException("Missing the required parameter 'timePunchId' when calling updateById(Async)");
        }

        // verify the required parameter 'timePunchesUpdateByIdRequest' is set
        if (timePunchesUpdateByIdRequest == null) {
            throw new ApiException("Missing the required parameter 'timePunchesUpdateByIdRequest' when calling updateById(Async)");
        }

        return updateByIdCall(companyId, timePunchId, timePunchesUpdateByIdRequest, xApiVersion, xCompanyGuid, _callback);

    }


    private ApiResponse<TimePunchesUpdateByIdResponse> updateByIdWithHttpInfo(Long companyId, Long timePunchId, TimePunchesUpdateByIdRequest timePunchesUpdateByIdRequest, String xApiVersion, UUID xCompanyGuid) throws ApiException {
        okhttp3.Call localVarCall = updateByIdValidateBeforeCall(companyId, timePunchId, timePunchesUpdateByIdRequest, xApiVersion, xCompanyGuid, null);
        Type localVarReturnType = new TypeToken<TimePunchesUpdateByIdResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateByIdAsync(Long companyId, Long timePunchId, TimePunchesUpdateByIdRequest timePunchesUpdateByIdRequest, String xApiVersion, UUID xCompanyGuid, final ApiCallback<TimePunchesUpdateByIdResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateByIdValidateBeforeCall(companyId, timePunchId, timePunchesUpdateByIdRequest, xApiVersion, xCompanyGuid, _callback);
        Type localVarReturnType = new TypeToken<TimePunchesUpdateByIdResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateByIdRequestBuilder {
        private final Long companyId;
        private final Long timePunchId;
        private Integer departmentId;
        private Integer roleId;
        private OffsetDateTime clockedIn;
        private OffsetDateTime clockedOut;
        private String notes;
        private Integer tips;
        private List<TimePunchesUpdateByIdRequestBreaksInner> breaks;
        private String xApiVersion;
        private UUID xCompanyGuid;

        private UpdateByIdRequestBuilder(Long companyId, Long timePunchId) {
            this.companyId = companyId;
            this.timePunchId = timePunchId;
        }

        /**
         * Set departmentId
         * @param departmentId Department ID (optional)
         * @return UpdateByIdRequestBuilder
         */
        public UpdateByIdRequestBuilder departmentId(Integer departmentId) {
            this.departmentId = departmentId;
            return this;
        }
        
        /**
         * Set roleId
         * @param roleId The ID of the role that the user is clocking in to work for. (optional)
         * @return UpdateByIdRequestBuilder
         */
        public UpdateByIdRequestBuilder roleId(Integer roleId) {
            this.roleId = roleId;
            return this;
        }
        
        /**
         * Set clockedIn
         * @param clockedIn The start date and time when the user clocked in. Formatted as ISO8601 datetime in UTC timezone. (optional)
         * @return UpdateByIdRequestBuilder
         */
        public UpdateByIdRequestBuilder clockedIn(OffsetDateTime clockedIn) {
            this.clockedIn = clockedIn;
            return this;
        }
        
        /**
         * Set clockedOut
         * @param clockedOut The start date and time when the user clocked out. Formatted as ISO8601 datetime in UTC timezone. (optional)
         * @return UpdateByIdRequestBuilder
         */
        public UpdateByIdRequestBuilder clockedOut(OffsetDateTime clockedOut) {
            this.clockedOut = clockedOut;
            return this;
        }
        
        /**
         * Set notes
         * @param notes Additional notes for a shift. (optional)
         * @return UpdateByIdRequestBuilder
         */
        public UpdateByIdRequestBuilder notes(String notes) {
            this.notes = notes;
            return this;
        }
        
        /**
         * Set tips
         * @param tips Tips declared for the shift in cents (optional)
         * @return UpdateByIdRequestBuilder
         */
        public UpdateByIdRequestBuilder tips(Integer tips) {
            this.tips = tips;
            return this;
        }
        
        /**
         * Set breaks
         * @param breaks List of breaks during a shift. Breaks must always be included in a correct state in update requests. The absence of an existing break in the payload implies that it should be deleted. (optional)
         * @return UpdateByIdRequestBuilder
         */
        public UpdateByIdRequestBuilder breaks(List<TimePunchesUpdateByIdRequestBreaksInner> breaks) {
            this.breaks = breaks;
            return this;
        }
        
        /**
         * Set xApiVersion
         * @param xApiVersion 7shifts API version (optional)
         * @return UpdateByIdRequestBuilder
         */
        public UpdateByIdRequestBuilder xApiVersion(String xApiVersion) {
            this.xApiVersion = xApiVersion;
            return this;
        }
        
        /**
         * Set xCompanyGuid
         * @param xCompanyGuid Company GUID (optional)
         * @return UpdateByIdRequestBuilder
         */
        public UpdateByIdRequestBuilder xCompanyGuid(UUID xCompanyGuid) {
            this.xCompanyGuid = xCompanyGuid;
            return this;
        }
        
        /**
         * Build call for updateById
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            TimePunchesUpdateByIdRequest timePunchesUpdateByIdRequest = buildBodyParams();
            return updateByIdCall(companyId, timePunchId, timePunchesUpdateByIdRequest, xApiVersion, xCompanyGuid, _callback);
        }

        private TimePunchesUpdateByIdRequest buildBodyParams() {
            TimePunchesUpdateByIdRequest timePunchesUpdateByIdRequest = new TimePunchesUpdateByIdRequest();
            timePunchesUpdateByIdRequest.departmentId(this.departmentId);
            timePunchesUpdateByIdRequest.roleId(this.roleId);
            timePunchesUpdateByIdRequest.clockedIn(this.clockedIn);
            timePunchesUpdateByIdRequest.clockedOut(this.clockedOut);
            timePunchesUpdateByIdRequest.notes(this.notes);
            timePunchesUpdateByIdRequest.tips(this.tips);
            timePunchesUpdateByIdRequest.breaks(this.breaks);
            return timePunchesUpdateByIdRequest;
        }

        /**
         * Execute updateById request
         * @return TimePunchesUpdateByIdResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public TimePunchesUpdateByIdResponse execute() throws ApiException {
            TimePunchesUpdateByIdRequest timePunchesUpdateByIdRequest = buildBodyParams();
            ApiResponse<TimePunchesUpdateByIdResponse> localVarResp = updateByIdWithHttpInfo(companyId, timePunchId, timePunchesUpdateByIdRequest, xApiVersion, xCompanyGuid);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateById request with HTTP info returned
         * @return ApiResponse&lt;TimePunchesUpdateByIdResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TimePunchesUpdateByIdResponse> executeWithHttpInfo() throws ApiException {
            TimePunchesUpdateByIdRequest timePunchesUpdateByIdRequest = buildBodyParams();
            return updateByIdWithHttpInfo(companyId, timePunchId, timePunchesUpdateByIdRequest, xApiVersion, xCompanyGuid);
        }

        /**
         * Execute updateById request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TimePunchesUpdateByIdResponse> _callback) throws ApiException {
            TimePunchesUpdateByIdRequest timePunchesUpdateByIdRequest = buildBodyParams();
            return updateByIdAsync(companyId, timePunchId, timePunchesUpdateByIdRequest, xApiVersion, xCompanyGuid, _callback);
        }
    }

    /**
     * Update Time Punch
     * 
     * @param companyId Company id (required)
     * @param timePunchId Time punch id (required)
     * @param timePunchesUpdateByIdRequest  (required)
     * @return UpdateByIdRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public UpdateByIdRequestBuilder updateById(Long companyId, Long timePunchId) throws IllegalArgumentException {
        if (companyId == null) throw new IllegalArgumentException("\"companyId\" is required but got null");
        if (timePunchId == null) throw new IllegalArgumentException("\"timePunchId\" is required but got null");
        return new UpdateByIdRequestBuilder(companyId, timePunchId);
    }
}
